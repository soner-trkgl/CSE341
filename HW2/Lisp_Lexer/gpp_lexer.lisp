;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 			Soner Türkoğlu 161044013		   ;;
;;											   ;;
;;	Compilation tips	-> 					   ;;
;;	clisp filename.lisp (optional file name)   ;;
;;											   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *arr* '(nil nil KW_AND KW_OR KW_NOT KW_EQUAL KW_LESS KW_NIL KW_LIST KW_APPEND KW_CONCAT KW_SET KW_DEFFUN KW_FOR 
				 KW_IF KW_EXIT KW_LOAD KW_DISP KW_TRUE KW_FALSE  OP_PLUS OP_MUNIS OP_DIV OP_MULT OP_OP OP_CP OP_DBLMULT 
				 OP_OC OP_CC OP_COMMA COMMENT VALUE IDENTIFIER SYNTAX_ERROR ))

(defparameter *alphabetupper* '(#\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z ) )
(defparameter *alphabetlow* '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z ) )
(defparameter *digits* '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9) )


(defparameter *op_or_oc* 0)
(defparameter *check* 0)
(defparameter *return* -1)



;;
;; 	gppinterpreter with optional file argument
;;


(defun gppinterpreter (&optional (file_name nil))
	(with-open-file (str_w "parsed_lisp.txt" :direction	:output :if-exists :supersede)
		(if (equal nil file_name)
			(do ((x (read-line) (read-line) ))
				((= 0 (length x)))
				(do ((y 0 (+ y *check*)))
					((= y (length x)) )
					(setf *check* 0)
					(setf *return* -1)
					(setf sub_str (subseq x y))
					(space_ch sub_str)
					(new_line sub_str)
					(kw_and sub_str)
					(kw_or sub_str)
					(kw_not sub_str)
					(kw_equal sub_str)
					(kw_less sub_str)
					(kw_nil sub_str)
					(kw_list sub_str)
					(kw_append sub_str)
					(kw_concat sub_str)
					(kw_set sub_str)
					(kw_deffun sub_str)
					(kw_for sub_str)
					(kw_if sub_str)
					(kw_exit sub_str)
					(kw_load sub_str)
					(kw_disp sub_str)
					(kw_true sub_str)
					(kw_false sub_str)
					(op_plus sub_str)
					(op_minus sub_str)
					(op_div sub_str)
					(op_mult sub_str)
					(op_op sub_str)
					(op_cp sub_str)
					(op_dblmult sub_str)
					(op_oc_or_cc sub_str)
					(op_comma sub_str)
					(comment sub_str)
					(value sub_str)
					(identifier sub_str)
					(syntax_error sub_str)
					(if (> *return* 1)
						(if (= *return* 33)
							(progn (format str_w "~A ~A can not be tokenized ~%" (nth  *return* *arr* ) (subseq sub_str 0 *check* )) (setf set_err 1)  (return) )
							(progn (format str_w "~A~%" (nth  *return* *arr* )) (setf set_err 0) )
						)
					)
				)
				(if (= set_err 1)
					(progn (format t "~A ~A can not be tokenized ~%" (nth  *return* *arr* ) (subseq sub_str 0 *check* )) (return) )
				)
			)
			(with-open-file (str_r file_name :direction :input)
				(do ((x (read-line str_r nil 'eof) (read-line str_r nil 'eof) ))
					((equal x 'eof) )
					(do ((y 0 (+ y *check*)))
						((= (length x) y) )
						(setf *check* 0)
						(setf *return* -1)
						(setf sub_str (subseq x y))
						(space_ch sub_str)
						(new_line sub_str)
						(kw_and sub_str)
						(kw_or sub_str)
						(kw_not sub_str)
						(kw_equal sub_str)
						(kw_less sub_str)
						(kw_nil sub_str)
						(kw_list sub_str)
						(kw_append sub_str)
						(kw_concat sub_str)
						(kw_set sub_str)
						(kw_deffun sub_str)
						(kw_for sub_str)
						(kw_if sub_str)
						(kw_exit sub_str)
						(kw_load sub_str)
						(kw_disp sub_str)
						(kw_true sub_str)
						(kw_false sub_str)
						(op_plus sub_str)
						(op_minus sub_str)
						(op_div sub_str)
						(op_mult sub_str)
						(op_op sub_str)
						(op_cp sub_str)
						(op_dblmult sub_str)
						(op_oc_or_cc sub_str)
						(op_comma sub_str)
						(comment sub_str)
						(value sub_str)
						(identifier sub_str)
						(syntax_error sub_str)
						(if (> *return* 1)
							(if (= *return* 33)
								(progn (format str_w "~A ~A can not be tokenized ~%" (nth  *return* *arr* ) (subseq sub_str 0 *check* )) (setf set_err 1)  (return) )
								(progn (format str_w "~A~%" (nth  *return* *arr* )) (setf set_err 0) )
							)
						)	
					)
					(if (= set_err 1)
						(progn (format t "~A ~A can not be tokenized ~%" (nth  *return* *arr* ) (subseq sub_str 0 *check* )) (return) )
					)
				)
				
						

			)

		)		
	)
	
)


;;
;; 		DFA control functions
;;
;;


(defun space_ch (sub_str)
	(if (or ( equal (char sub_str 0) #\Space) (equal (char sub_str 0) #\Tab))
		(if (setf *check* 1)
			(setf *return* 0)
		)
	)
	
)
		
(defun new_line (sub_str)

	(if (equal (char sub_str 0) #\Newline)
		(if (setf *check* 1)
			(setf *return* 1)
		)
	)

)
(defun kw_and (sub_str)
	(if (> (length sub_str) 2)	
		(if (and 
				(or (equal (char sub_str 0) #\a) (equal (char sub_str 0) #\A) ) 
				(or (equal (char sub_str 1) #\n) (equal (char sub_str 1) #\N) )
				(or (equal (char sub_str 2) #\d) (equal (char sub_str 2) #\D) )
			) 
			(if (< *check* 3)
				(progn
					(setf *check* 3)
					(setf *return* 2)
				)
			)

		)
	)

)
(defun kw_or (sub_str)
	(if (> (length sub_str) 1)
		(if (and 
				(or (equal (char sub_str 0) #\o) (equal (char sub_str 0) #\O) ) 
				(or (equal (char sub_str 1) #\r) (equal (char sub_str 1) #\R) )
			) 
			(if (< *check* 2)
				(progn
					(setf *check* 2)
					(setf *return* 3)
				)
			)
		)
	)
)
(defun kw_not (sub_str)
	(if (> (length sub_str) 2)
		(if (and 
				(or (equal (char sub_str 0) #\n) (equal (char sub_str 0) #\N) ) 
				(or (equal (char sub_str 1) #\o) (equal (char sub_str 1) #\O) )
				(or (equal (char sub_str 2) #\t) (equal (char sub_str 2) #\T) )
			) 
			(if (< *check* 3)
				(progn
					(setf *check* 3)
					(setf *return* 4)
				)
			)

		)
	)

)
(defun kw_equal (sub_str)
	(if (> (length sub_str) 4)
		(if (and 
				(or (equal (char sub_str 0) #\e) (equal (char sub_str 0) #\E) ) 
				(or (equal (char sub_str 1) #\q) (equal (char sub_str 1) #\Q) )
				(or (equal (char sub_str 2) #\u) (equal (char sub_str 2) #\U) )
				(or (equal (char sub_str 3) #\a) (equal (char sub_str 3) #\A) )
				(or (equal (char sub_str 4) #\l) (equal (char sub_str 4) #\L) )
			) 
			(if (< *check* 5)
				(progn
					(setf *check* 5)
					(setf *return* 5)
				)
			)

		)
	)

)
(defun kw_less (sub_str)
	(if (> (length sub_str) 3)
		(if (and 
				(or (equal (char sub_str 0) #\l) (equal (char sub_str 0) #\L) ) 
				(or (equal (char sub_str 1) #\e) (equal (char sub_str 1) #\E) )
				(or (equal (char sub_str 2) #\s) (equal (char sub_str 2) #\S) )
				(or (equal (char sub_str 3) #\s) (equal (char sub_str 3) #\S) )
						) 
			(if (< *check* 4)
				(progn
					(setf *check* 4)
					(setf *return* 6)
				)
			)

		)
	)

)
(defun kw_nil (sub_str)
	(if (> (length sub_str) 2)
		(if (and 
				(or (equal (char sub_str 0) #\n) (equal (char sub_str 0) #\N) ) 
				(or (equal (char sub_str 1) #\i) (equal (char sub_str 1) #\I) )
				(or (equal (char sub_str 2) #\l) (equal (char sub_str 2) #\L) )
						) 
			(if (< *check* 4)
				(progn
					(setf *check* 3)
					(setf *return* 7)
				)
			)

		)
	)

)
(defun kw_list (sub_str)
	(if (> (length sub_str) 3)
		(if (and 
				(or (equal (char sub_str 0) #\l) (equal (char sub_str 0) #\L) ) 
				(or (equal (char sub_str 1) #\i) (equal (char sub_str 1) #\I) )
				(or (equal (char sub_str 2) #\s) (equal (char sub_str 2) #\S) )
				(or (equal (char sub_str 3) #\t) (equal (char sub_str 3) #\T) )
						) 
			(if (< *check* 4)
				(progn
					(setf *check* 4)
					(setf *return* 8)
				)
			)

		)
	)
)
(defun kw_append (sub_str)
	(if (> (length sub_str) 5)
		(if (and 
				(or (equal (char sub_str 0) #\a) (equal (char sub_str 0) #\A) ) 
				(or (equal (char sub_str 1) #\p) (equal (char sub_str 1) #\P) )
				(or (equal (char sub_str 2) #\p) (equal (char sub_str 2) #\P) )
				(or (equal (char sub_str 3) #\e) (equal (char sub_str 3) #\E) )
				(or (equal (char sub_str 4) #\n) (equal (char sub_str 4) #\N) )
				(or (equal (char sub_str 5) #\d) (equal (char sub_str 5) #\D) )
						) 
			(if (< *check* 6)
				(progn
					(setf *check* 6)
					(setf *return* 9)
				)
			)

		)
	)
)
(defun kw_concat (sub_str)
	(if (> (length sub_str) 5)
		(if (and 
				(or (equal (char sub_str 0) #\c) (equal (char sub_str 0) #\C) ) 
				(or (equal (char sub_str 1) #\o) (equal (char sub_str 1) #\O) )
				(or (equal (char sub_str 2) #\n) (equal (char sub_str 2) #\N) )
				(or (equal (char sub_str 3) #\c) (equal (char sub_str 3) #\C) )
				(or (equal (char sub_str 4) #\a) (equal (char sub_str 4) #\A) )
				(or (equal (char sub_str 5) #\t) (equal (char sub_str 5) #\T) )
						) 
			(if (< *check* 6)
				(progn
					(setf *check* 6)
					(setf *return* 10)
				)
			)

		)
	)

)
(defun kw_set (sub_str)
	(if (> (length sub_str) 2)
		(if (and 
				(or (equal (char sub_str 0) #\s) (equal (char sub_str 0) #\S) ) 
				(or (equal (char sub_str 1) #\e) (equal (char sub_str 1) #\E) )
				(or (equal (char sub_str 2) #\t) (equal (char sub_str 2) #\T) )
						) 
			(if (< *check* 3)
				(progn
					(setf *check* 3)
					(setf *return* 11)
				)
			)

		)
	)
)
(defun kw_deffun (sub_str)
	(if (> (length sub_str) 5)
		(if (and 
				(or (equal (char sub_str 0) #\d) (equal (char sub_str 0) #\D) ) 
				(or (equal (char sub_str 1) #\e) (equal (char sub_str 1) #\E) )
				(or (equal (char sub_str 2) #\f) (equal (char sub_str 2) #\F) )
				(or (equal (char sub_str 3) #\f) (equal (char sub_str 3) #\F) )
				(or (equal (char sub_str 4) #\u) (equal (char sub_str 4) #\U) )
				(or (equal (char sub_str 5) #\n) (equal (char sub_str 5) #\N) )
						) 
			(if (< *check* 6)
				(progn
					(setf *check* 6)
					(setf *return* 12)
				)
			)

		)
	)

)
(defun kw_for (sub_str)
	(if (> (length sub_str) 2)
		(if (and 
				(or (equal (char sub_str 0) #\f) (equal (char sub_str 0) #\F) ) 
				(or (equal (char sub_str 1) #\o) (equal (char sub_str 1) #\O) )
				(or (equal (char sub_str 2) #\r) (equal (char sub_str 2) #\R) )
				)
			(if (< *check* 3)
				(progn
					(setf *check* 3)
					(setf *return* 13)
				)
			)

		)
	)

)
(defun kw_if (sub_str)
	(if (> (length sub_str) 1)
		(if (and 
				(or (equal (char sub_str 0) #\i) (equal (char sub_str 0) #\I) ) 
				(or (equal (char sub_str 1) #\f) (equal (char sub_str 1) #\F) )
							) 
			(if (< *check* 2)
				(progn
					(setf *check* 2)
					(setf *return* 14)
				)
			)

		)
	)
)
(defun kw_exit (sub_str)
	(if (> (length sub_str) 3)
		(if (and 
				(or (equal (char sub_str 0) #\e) (equal (char sub_str 0) #\E) ) 
				(or (equal (char sub_str 1) #\x) (equal (char sub_str 1) #\X) )
				(or (equal (char sub_str 2) #\i) (equal (char sub_str 2) #\I) )
				(or (equal (char sub_str 3) #\t) (equal (char sub_str 3) #\T) )
						) 
			(if (< *check* 4)
				(progn
					(setf *check* 4)
					(setf *return* 15)
				)
			)

		)
	)
)
(defun kw_load (sub_str)
	(if (> (length sub_str) 3)
		(if (and 
				(or (equal (char sub_str 0) #\l) (equal (char sub_str 0) #\L) ) 
				(or (equal (char sub_str 1) #\o) (equal (char sub_str 1) #\O) )
				(or (equal (char sub_str 2) #\a) (equal (char sub_str 2) #\A) )
				(or (equal (char sub_str 3) #\d) (equal (char sub_str 3) #\D) )
						) 
			(if (< *check* 4)
				(progn
					(setf *check* 4)
					(setf *return* 16)
				)
			)

		)
	)
)
(defun kw_disp (sub_str)
	(if (> (length sub_str) 3)
		(if (and 
				(or (equal (char sub_str 0) #\d) (equal (char sub_str 0) #\D) ) 
				(or (equal (char sub_str 1) #\i) (equal (char sub_str 1) #\I) )
				(or (equal (char sub_str 2) #\s) (equal (char sub_str 2) #\S) )
				(or (equal (char sub_str 3) #\p) (equal (char sub_str 3) #\P) )
						) 
			(if (< *check* 4)
				(progn
					(setf *check* 4)
					(setf *return* 17)
				)
			)

		)
	)
)
(defun kw_true (sub_str)
	(if (> (length sub_str) 3)
		(if (and 
				(or (equal (char sub_str 0) #\t) (equal (char sub_str 0) #\T) ) 
				(or (equal (char sub_str 1) #\r) (equal (char sub_str 1) #\R) )
				(or (equal (char sub_str 2) #\u) (equal (char sub_str 2) #\U) )
				(or (equal (char sub_str 3) #\e) (equal (char sub_str 3) #\E) )
						) 
			(if (< *check* 4)
				(progn
					(setf *check* 4)
					(setf *return* 18)
				)
			)

		)
	)	
)
(defun kw_false (sub_str)
	(if (> (length sub_str) 4)
		(if (and 
				(or (equal (char sub_str 0) #\f) (equal (char sub_str 0) #\F) ) 
				(or (equal (char sub_str 1) #\a) (equal (char sub_str 1) #\A) )
				(or (equal (char sub_str 2) #\l) (equal (char sub_str 2) #\L) )
				(or (equal (char sub_str 3) #\s) (equal (char sub_str 3) #\S) )
				(or (equal (char sub_str 4) #\e) (equal (char sub_str 4) #\E) )
						) 
			(if (< *check* 5)
				(progn
					(setf *check* 5)
					(setf *return* 19)
				)
			)

		)
	)
)
(defun op_plus (sub_str)
	(if (equal (char sub_str 0) #\+) 
		(progn
			(setf *check* 1)
			(setf *return* 20)
		)
	)

)
(defun op_minus (sub_str)
	(if (equal (char sub_str 0) #\-) 
		(progn
			(setf *check* 1)
			(setf *return* 21)
		)
	)
)
(defun op_div (sub_str)
	(if (equal (char sub_str 0) #\/) 
		(progn
			(setf *check* 1)
			(setf *return* 22)
		)
	)

)
(defun op_mult (sub_str)
	(if (equal (char sub_str 0) #\* ) 
		(progn
			(setf *check* 1)
			(setf *return* 23)
		)
	)

)
(defun op_op (sub_str)
	(if (equal (char sub_str 0) #\( ) 
		(progn
			(setf *check* 1)
			(setf *return* 24)
		)
	)

)
(defun op_cp (sub_str)
	(if (equal (char sub_str 0) #\) )  
		(progn
			(setf *check* 1)
			(setf *return* 25)
		)
	)

)
(defun op_dblmult (sub_str)
	(if (> (length sub_str) 1)
		(if (and (equal (char sub_str 0) #\* ) (equal (char sub_str 1) #\* ) )
			(progn
				(setf *check* 2)
				(setf *return* 26)
			)
		)
	)
)
(defun op_oc_or_cc (sub_str)
	(if (equal (char sub_str 0) #\" ) 
		(if (evenp *op_or_oc*)
			(progn
				(setf *op_or_oc* (+ *op_or_oc* 1))
				(setf *check* 1)
				(setf *return* 27)
			)
			(progn
				(setf *op_or_oc* (+ *op_or_oc* 1))
				(setf *check* 1)
				(setf *return* 28)
			)
		)
	)

)

(defun op_comma (sub_str)
	(if (equal (char sub_str 0) #\, )  
		(progn
			(setf *check* 1)
			(setf *return* 29)
		)
	)

)

(defun comment (sub_str)
	(if (> (length sub_str) 1)
		(if (and (equal (char sub_str 0) #\; ) (equal (char sub_str 1) #\; ) )  
			(do ((x 2 (+ x 1) ) )
				( 	(= (length sub_str) x) 
					(setf *check* x) (setf *return* 30)
				)
			)
		)

	)
)
(defun value (sub_str)
	(if (and (equal (char sub_str 0) #\0 ) (or (equal (char sub_str 1) #\Space) (equal (char sub_str 1) #\Tab) (= (length sub_str) 1) )) 
		(progn
			(setf *check* 1)
			(setf *return* 31)
		)
		(if (position (char sub_str 0) (cdr *digits*))
			(do ((x 1 (+ x 1) ))
				( (or (= x (length sub_str))  (null (position (char sub_str x) *digits*) ) )  
					(if (< *check* x)
						(progn
							(setf *check* x)
							(setf *return* 31)
						)
					)
				)
			)
		)
	)

)
(defun identifier (sub_str)
	(if (or (not (null (position (char sub_str 0) *alphabetlow*))) (not (null (position (char sub_str 0) *alphabetupper*))))
		(do ((x 1 (+ x 1) ) )
			( (or 	
					(= x (length sub_str) )
					(and (null (position (char sub_str x) *alphabetupper*)) 
				       (null (position (char sub_str x) *alphabetlow*)) 
				       (null (position (char sub_str x) *digits*))
				  	)
				  	(and  (< (+ 1 x) (length sub_str) )
				  		(equal (char sub_str x) #\; )
				  		(equal (char sub_str (+ 1 x)) #\; )
				  	) 
				  	(equal (char sub_str x) #\Space)
				  	(equal (char sub_str x) #\Tab)
				  	(equal (char sub_str x) #\( )
				  	(equal (char sub_str x) #\) )

			  )
			 
				(if (< *check* x)
					(progn
						(setf *check* x)
						(setf *return* 32)
					)
				)
			 
			)
		)
	)

)

(defun syntax_error (sub_str)
	(do ((x 0 (+ x 1)) )
		( 	(or (= (length sub_str) x ) (equal (char sub_str x) #\Space ) 
				(equal (char sub_str x) #\Tab ) (equal (char sub_str x) #\( ) 
				(equal (char sub_str x) #\) ) )
			(if (< *check* x) (progn (setf *check* x) (setf *return* 33)) ) 
		)
		(if (and (or (equal (char sub_str x) #\+) (equal (char sub_str x) #\-)) (= x 0) (> (length sub_str) 1 ) 
				 (not (null (position (char sub_str 1) *digits*))) 
			)
			(progn 
				(setf flag 1)
				(do ((y 2 (+ 1 y)))
					((or (= (length sub_str) y ) (equal (char sub_str y) #\Space ) (equal (char sub_str y) #\Tab ) 
						(equal (char sub_str y) #\( ) (equal (char sub_str y) #\) ) 
						(and (equal (char sub_str y) #\; ) (< (length sub_str) (+ 1 y) ) (equal (char sub_str y) #\; ) )	))
					(if (not (null (position (char sub_str y) *digits* ) ) ) 
						(setf flag 1)
						(progn  (setf flag 0) (return))
					)
				)
				(if (= flag 1)
					(return)
				)
			)
		)
		(if (and (equal (char sub_str x ) #\; ) (and  (> (length sub_str) (+ 1 x) ) (equal (char sub_str (+ x 1) ) #\; ) ) )
			(return)
		)
	)
)


;;
;;		run program
;;
;;

(if (equal (nth 0 *args*) nil)
		(gppinterpreter)
		(if (probe-file (nth 0 *args*))
			(gppinterpreter	(nth 0 *args* ))
			(format t "~A file not exist" (nth 0 *args* ) )
		)
)
